"""
Pytest configuration and fixtures for API tests.
"""

import pytest
from datetime import datetime, timedelta, timezone
from uuid import uuid4
from typing import Generator
from unittest.mock import patch, MagicMock, AsyncMock

from fastapi.testclient import TestClient
from jose import jwt
from sqlalchemy.orm import Session

from app.main import app
from app.core.config import settings
from app.models.base import SessionLocal
from app.models.models import Organization, User
from app.models.enums import UserRole
from app.services.audit import AuditService


# =============================================================================
# Pytest Session Hooks - Database Seeding
# =============================================================================


def pytest_sessionstart(session):
    """
    Pytest hook called before any tests run.

    Seeds test database with organizations and users needed for JWT token validation.
    The seeded data matches UUIDs used in JWT tokens generated by test fixtures.

    This ensures that workflow creation and other tests that require valid
    organization_id and user_id references will pass.
    """
    import os
    import sys
    from pathlib import Path

    # Only seed in CI or if DATABASE_URL points to test database
    database_url = os.getenv("DATABASE_URL", "")
    is_ci = os.getenv("CI") == "true"
    is_test_db = "qteria_test" in database_url or (is_ci and "neon.tech" in database_url)

    if not is_test_db:
        print("\nâš ï¸  Skipping test data seeding - DATABASE_URL does not point to test database")
        print(f"   Current DATABASE_URL: {database_url}")
        print(f"   CI environment: {is_ci}")
        return

    try:
        # Import seed function
        # Add parent directory to path to import from scripts/
        sys.path.insert(0, str(Path(__file__).parent.parent))
        from scripts.seed_test_data import seed_test_data

        print("\n" + "=" * 60)
        print("ðŸŒ± Seeding test database (pytest_sessionstart)")
        print("=" * 60)
        seed_test_data()
        print("=" * 60)
        print()

    except Exception as e:
        print(f"\nâŒ Failed to seed test database: {e}")
        print("   Tests CANNOT run without seeded organization/user references.")
        print("   To manually seed, run: python scripts/seed_test_data.py\n")
        # Fail fast - don't allow 107 tests to fail with cryptic foreign key errors
        pytest.exit("Test data seeding failed - stopping all tests", returncode=1)


def pytest_sessionfinish(session, exitstatus):
    """
    Pytest hook called after all tests complete.

    Optional cleanup hook - currently does nothing because:
    1. CI uses ephemeral test databases (destroyed after pipeline)
    2. Local dev benefits from keeping data for debugging failed tests
    3. Each test should use transactions/rollback for isolation

    If you need to clear test data, run: python scripts/clear_test_data.py
    """
    pass


@pytest.fixture
def mock_audit_service():
    """
    Mock AuditService for unit tests to avoid database dependencies.

    This allows unit tests to run without requiring seeded database data
    while still testing the core RBAC logic.

    NOTE: This fixture is NOT autouse. Tests that need mocked audit service
    should explicitly request it, or use the unit_test_mocks fixture.
    Integration tests should NOT use this fixture.
    """
    with (
        patch.object(AuditService, "log_event", return_value=MagicMock()) as mock_event,
        patch.object(
            AuditService, "log_auth_success", return_value=MagicMock()
        ) as mock_auth_success,
        patch.object(
            AuditService, "log_auth_failure", return_value=MagicMock()
        ) as mock_auth_failure,
        patch.object(
            AuditService, "log_token_invalid", return_value=MagicMock()
        ) as mock_token_invalid,
        patch.object(
            AuditService, "log_token_expired", return_value=MagicMock()
        ) as mock_token_expired,
        patch.object(
            AuditService, "log_authz_denied", return_value=MagicMock()
        ) as mock_authz_denied,
        patch.object(
            AuditService, "log_multi_tenancy_violation", return_value=MagicMock()
        ) as mock_mt_violation,
        patch.object(
            AuditService, "log_permission_denied", return_value=MagicMock()
        ) as mock_perm_denied,
        patch.object(
            AuditService, "log_access_granted", return_value=MagicMock()
        ) as mock_access_granted,
        patch.object(
            AuditService, "log_workflow_created", return_value=MagicMock()
        ) as mock_workflow_created,
        patch.object(
            AuditService, "log_workflow_updated", return_value=MagicMock()
        ) as mock_workflow_updated,
    ):
        yield {
            "log_event": mock_event,
            "log_auth_success": mock_auth_success,
            "log_auth_failure": mock_auth_failure,
            "log_token_invalid": mock_token_invalid,
            "log_token_expired": mock_token_expired,
            "log_authz_denied": mock_authz_denied,
            "log_multi_tenancy_violation": mock_mt_violation,
            "log_permission_denied": mock_perm_denied,
            "log_access_granted": mock_access_granted,
            "log_workflow_created": mock_workflow_created,
            "log_workflow_updated": mock_workflow_updated,
        }


@pytest.fixture(autouse=True, scope="function")
def _auto_mock_vercel_blob(request):
    """
    Mock Vercel Blob storage for integration tests.

    This fixture automatically mocks all Blob storage operations to avoid
    requiring BLOB_READ_WRITE_TOKEN in CI environment.

    The mock returns realistic Vercel Blob API responses matching production format.

    NOTE: This fixture is autouse=True but skips for tests marked with @pytest.mark.unit
    to avoid conflicts with unit test patches. This provides more robust exclusion
    than filename matching.

    The fixture is prefixed with _ to indicate it's an internal autouse fixture
    and to avoid naming collisions with test-specific mock_blob_storage fixtures.

    Example usage in integration tests:
        def test_upload_pdf(client, _auto_mock_vercel_blob):
            # _auto_mock_vercel_blob["put"] gives access to mock for assertions
            response = client.post("/api/v1/documents/upload", ...)
            assert _auto_mock_vercel_blob["put"].called
    """
    # Skip for blob storage unit tests marked with @pytest.mark.unit
    if request.node.get_closest_marker("unit"):
        yield None
        return

    # Patch at module level where imports are defined (vercel_blob.put, not app.services.blob_storage.put)
    # This is necessary because blob_storage.py imports these functions dynamically inside methods
    with (
        patch("vercel_blob.put", new_callable=AsyncMock) as mock_put,
        patch("vercel_blob.delete", new_callable=AsyncMock) as mock_del,
        patch.dict("os.environ", {"BLOB_READ_WRITE_TOKEN": "mock-token-for-integration-tests"}),
    ):

        # Mock Vercel Blob upload response
        # Format matches actual Vercel Blob API: https://vercel.com/docs/storage/vercel-blob
        async def mock_upload(pathname: str, body, options=None, **kwargs):
            """Mock put() function to return Vercel Blob response format."""
            options = options or {}
            return {
                "url": f"https://blob.vercel-storage.com/{pathname}?token=mock",
                "pathname": pathname,
                "contentType": options.get("contentType", "application/pdf"),
            }

        mock_put.side_effect = mock_upload

        # Mock delete returns None (Vercel Blob delete has no return value)
        async def mock_delete(url: str, **kwargs):
            """Mock delete() function - returns None like actual Vercel Blob API."""
            return None

        mock_del.side_effect = mock_delete

        yield {
            "put": mock_put,
            "delete": mock_del,
        }


@pytest.fixture
def client() -> Generator[TestClient, None, None]:
    """Create a test client for the FastAPI app."""
    with TestClient(app) as c:
        yield c


def create_test_token(
    user_id: str | None = None,
    email: str = "test@example.com",
    role: str = "project_handler",
    organization_id: str | None = None,
    name: str = "Test User",
    expired: bool = False,
    missing_fields: list[str] | None = None,
) -> str:
    """
    Create a JWT token for testing.

    Args:
        user_id: User UUID (auto-generated if not provided)
        email: User email
        role: User role
        organization_id: Organization UUID (auto-generated if not provided)
        name: User display name
        expired: If True, create an expired token
        missing_fields: List of fields to omit from token

    Returns:
        JWT token string
    """
    if user_id is None:
        user_id = str(uuid4())
    if organization_id is None:
        organization_id = str(uuid4())

    # Set expiration
    if expired:
        exp = datetime.now(timezone.utc) - timedelta(hours=1)
    else:
        exp = datetime.now(timezone.utc) + timedelta(hours=1)

    payload = {
        "sub": user_id,
        "email": email,
        "role": role,
        "org_id": organization_id,
        "name": name,
        "iat": datetime.now(timezone.utc).timestamp(),
        "exp": exp.timestamp(),
    }

    # Remove specified fields
    if missing_fields:
        for field in missing_fields:
            payload.pop(field, None)

    return jwt.encode(payload, settings.JWT_SECRET, algorithm=settings.JWT_ALGORITHM)


@pytest.fixture
def admin_token() -> str:
    """Create a JWT token for an admin user (uses seeded test data)."""
    return create_test_token(
        user_id=TEST_USER_A_ID,
        organization_id=TEST_ORG_A_ID,
        role=UserRole.ADMIN.value,
        email="admin@test-org-a.com",
    )


@pytest.fixture
def process_manager_token() -> str:
    """Create a JWT token for a process manager user (uses seeded test data)."""
    return create_test_token(
        user_id=TEST_USER_A_PM_ID,
        organization_id=TEST_ORG_A_ID,
        role=UserRole.PROCESS_MANAGER.value,
        email="pm@test-org-a.com",
    )


@pytest.fixture
def project_handler_token() -> str:
    """Create a JWT token for a project handler user (uses seeded test data)."""
    return create_test_token(
        user_id=TEST_USER_A_PH_ID,
        organization_id=TEST_ORG_A_ID,
        role=UserRole.PROJECT_HANDLER.value,
        email="ph@test-org-a.com",
    )


@pytest.fixture
def expired_token() -> str:
    """Create an expired JWT token."""
    return create_test_token(expired=True)


@pytest.fixture
def invalid_token() -> str:
    """Create an invalid JWT token (wrong signature)."""
    return jwt.encode(
        {
            "sub": str(uuid4()),
            "email": "test@example.com",
            "role": "admin",
            "org_id": str(uuid4()),
        },
        "wrong_secret_key",
        algorithm="HS256",
    )


@pytest.fixture
def malformed_token() -> str:
    """Create a malformed token string."""
    return "not.a.valid.jwt.token"


@pytest.fixture
def token_missing_role() -> str:
    """Create a token missing the role field."""
    return create_test_token(missing_fields=["role"])


@pytest.fixture
def token_missing_org() -> str:
    """Create a token missing the org_id field."""
    return create_test_token(missing_fields=["org_id"])


@pytest.fixture
def token_invalid_role() -> str:
    """Create a token with an invalid role."""
    return create_test_token(role="invalid_role")


# Test organization and user IDs for multi-tenancy tests
# These are FIXED UUIDs that match the seed data in scripts/seed_test_data.py
# DO NOT change these values - they must match the seeded database records
TEST_ORG_A_ID = "f52414ec-67f4-43d5-b25c-1552828ff06d"
TEST_ORG_B_ID = "f171ee72-38bd-4a10-9682-a0c483ae365e"
TEST_USER_A_ID = "236c7750-e281-46d9-95b8-209ae5106221"  # Admin User A
TEST_USER_A_PM_ID = "bebffc00-a259-4fce-a873-371e6765811b"  # Process Manager A
TEST_USER_A_PH_ID = "a4c2e8f0-1234-4a5b-9c8d-7e6f5a4b3c2d"  # Project Handler A
TEST_USER_B_ID = "cf1a6da7-32bf-4f00-8893-0ec2e0bbbb22"  # Admin User B
TEST_USER_B_PM_ID = "11df2007-978f-4503-b89c-7b8eaa228859"  # Process Manager B
TEST_USER_B_PH_ID = "b5d3f9e1-2345-5b6c-ad9e-8f7e6b5c4d3e"  # Project Handler B


@pytest.fixture
def org_a_admin_token() -> str:
    """Admin token for organization A."""
    return create_test_token(
        user_id=TEST_USER_A_ID,
        email="admin@org-a.com",
        role=UserRole.ADMIN.value,
        organization_id=TEST_ORG_A_ID,
    )


@pytest.fixture
def org_b_admin_token() -> str:
    """Admin token for organization B."""
    return create_test_token(
        user_id=TEST_USER_B_ID,
        email="admin@org-b.com",
        role=UserRole.ADMIN.value,
        organization_id=TEST_ORG_B_ID,
    )


@pytest.fixture
def org_a_process_manager_token() -> str:
    """Process manager token for organization A."""
    return create_test_token(
        user_id=TEST_USER_A_PM_ID,
        email="pm@test-org-a.com",
        role=UserRole.PROCESS_MANAGER.value,
        organization_id=TEST_ORG_A_ID,
    )


@pytest.fixture
def org_a_project_handler_token() -> str:
    """Project handler token for organization A (uses seeded test data)."""
    return create_test_token(
        user_id=TEST_USER_A_PH_ID,
        email="ph@test-org-a.com",
        role=UserRole.PROJECT_HANDLER.value,
        organization_id=TEST_ORG_A_ID,
    )


@pytest.fixture
def org_b_project_handler_token() -> str:
    """Project handler token for organization B (uses seeded test data)."""
    return create_test_token(
        user_id=TEST_USER_B_PH_ID,
        email="ph@test-org-b.com",
        role=UserRole.PROJECT_HANDLER.value,
        organization_id=TEST_ORG_B_ID,
    )


# =============================================================================
# Database Session Fixtures
# =============================================================================


@pytest.fixture
def db_session() -> Generator[Session, None, None]:
    """Create a database session for integration tests."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@pytest.fixture
def test_organization(db_session: Session) -> Organization:
    """
    Return the first seeded test organization (Org A) from the database.

    This fixture relies on the pytest_sessionstart hook seeding the database
    with test organizations matching the UUIDs in TEST_ORG_A_ID.
    """
    org = db_session.query(Organization).filter(Organization.id == TEST_ORG_A_ID).first()
    if not org:
        pytest.fail(
            f"Test organization {TEST_ORG_A_ID} not found. "
            "Ensure pytest_sessionstart hook seeded the database."
        )
    return org


@pytest.fixture
def test_user(db_session: Session) -> User:
    """
    Return the first seeded admin user (User A) from the database.

    This fixture relies on the pytest_sessionstart hook seeding the database
    with test users matching the UUIDs in TEST_USER_A_ID.
    """
    user = db_session.query(User).filter(User.id == TEST_USER_A_ID).first()
    if not user:
        pytest.fail(
            f"Test user {TEST_USER_A_ID} not found. "
            "Ensure pytest_sessionstart hook seeded the database."
        )
    return user


# =============================================================================
# Document Test Fixtures
# =============================================================================


@pytest.fixture
def test_workflow_with_bucket(db_session: Session):
    """
    Create a real workflow with one bucket in test database for document upload tests.

    Returns tuple: (workflow_id, bucket_id)
    """
    from app.models.models import Workflow, Bucket
    from uuid import uuid4

    workflow_id = str(uuid4())
    bucket_id = str(uuid4())

    # Create workflow
    workflow = Workflow(
        id=workflow_id,
        name="Document Test Workflow",
        description="Workflow for document upload testing",
        organization_id=TEST_ORG_A_ID,
        created_by=TEST_USER_A_PM_ID,
        is_active=True,
    )
    db_session.add(workflow)
    db_session.flush()

    # Create bucket
    bucket = Bucket(
        id=bucket_id,
        workflow_id=workflow_id,
        name="Test Documents",
        required=True,
        order_index=0,
    )
    db_session.add(bucket)
    db_session.commit()

    yield (workflow_id, bucket_id)

    # Cleanup
    db_session.query(Bucket).filter(Bucket.id == bucket_id).delete()
    db_session.query(Workflow).filter(Workflow.id == workflow_id).delete()
    db_session.commit()


@pytest.fixture
def test_document_in_org_a(db_session: Session):
    """
    Create a real document in Organization A for download/deletion tests.

    Returns Document model instance.
    """
    from app.models.models import Document
    from uuid import uuid4
    from datetime import datetime, timezone

    doc_id = str(uuid4())

    document = Document(
        id=doc_id,
        file_name="test-document-org-a.pdf",
        file_size=1024,
        mime_type="application/pdf",
        storage_key=f"test-storage-key-{doc_id}",
        organization_id=TEST_ORG_A_ID,
        uploaded_by=TEST_USER_A_PH_ID,
        uploaded_at=datetime.now(timezone.utc),
    )
    db_session.add(document)
    db_session.commit()

    yield document

    # Cleanup
    db_session.query(Document).filter(Document.id == doc_id).delete()
    db_session.commit()


@pytest.fixture
def test_workflow_with_bucket_org_b(db_session: Session):
    """
    Create a real workflow with one bucket in Organization B for multi-tenancy tests.

    Returns tuple: (workflow_id, bucket_id)
    """
    from app.models.models import Workflow, Bucket
    from uuid import uuid4

    workflow_id = str(uuid4())
    bucket_id = str(uuid4())

    # Create workflow in Org B
    workflow = Workflow(
        id=workflow_id,
        name="Org B Document Test Workflow",
        description="Workflow for multi-tenancy testing",
        organization_id=TEST_ORG_B_ID,
        created_by=TEST_USER_B_PM_ID,
        is_active=True,
    )
    db_session.add(workflow)
    db_session.flush()

    # Create bucket
    bucket = Bucket(
        id=bucket_id,
        workflow_id=workflow_id,
        name="Org B Test Documents",
        required=True,
        order_index=0,
    )
    db_session.add(bucket)
    db_session.commit()

    yield (workflow_id, bucket_id)

    # Cleanup
    db_session.query(Bucket).filter(Bucket.id == bucket_id).delete()
    db_session.query(Workflow).filter(Workflow.id == workflow_id).delete()
    db_session.commit()


@pytest.fixture
def test_document_in_org_b(db_session: Session):
    """
    Create a real document in Organization B for multi-tenancy tests.

    Returns Document model instance.
    """
    from app.models.models import Document
    from uuid import uuid4
    from datetime import datetime, timezone

    doc_id = str(uuid4())

    document = Document(
        id=doc_id,
        file_name="test-document-org-b.pdf",
        file_size=2048,
        mime_type="application/pdf",
        storage_key=f"test-storage-key-{doc_id}",
        organization_id=TEST_ORG_B_ID,
        uploaded_by=TEST_USER_B_PH_ID,
        uploaded_at=datetime.now(timezone.utc),
    )
    db_session.add(document)
    db_session.commit()

    yield document

    # Cleanup
    db_session.query(Document).filter(Document.id == doc_id).delete()
    db_session.commit()


# =============================================================================
# Error Response Assertion Helpers
# =============================================================================


def assert_error_response(
    response,
    expected_code: str,
    expected_status: int,
) -> None:
    """
    Assert that HTTP response matches standardized error format.

    Validates that the response:
    - Has the expected HTTP status code
    - Contains "error" key at top level
    - Has "code" field matching expected_code (SCREAMING_SNAKE_CASE)
    - Has "message" field with non-empty string
    - Has "request_id" field for audit trail

    Args:
        response: FastAPI TestClient response object
        expected_code: Expected error code (e.g., "INVALID_TOKEN", "RESOURCE_NOT_FOUND")
        expected_status: Expected HTTP status code (e.g., 401, 404)

    Example:
        >>> response = client.get("/v1/workflows/invalid-id", headers=headers)
        >>> assert_error_response(response, "RESOURCE_NOT_FOUND", 404)
    """
    assert response.status_code == expected_status, (
        f"Expected status {expected_status}, got {response.status_code}. "
        f"Response body: {response.text}"
    )

    data = response.json()
    assert "error" in data, f"Missing 'error' key in response. Got: {data}"

    error = data["error"]
    assert "code" in error, f"Missing 'code' in error object. Got: {error}"
    assert (
        error["code"] == expected_code
    ), f"Expected error code '{expected_code}', got '{error['code']}'"

    assert "message" in error, f"Missing 'message' in error object. Got: {error}"
    assert isinstance(
        error["message"], str
    ), f"Error message should be string, got {type(error['message'])}"
    assert len(error["message"]) > 0, "Error message should not be empty"

    assert "request_id" in error, f"Missing 'request_id' in error object. Got: {error}"
