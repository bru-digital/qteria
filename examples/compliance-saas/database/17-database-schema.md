# Database Schema Design: Compliance Assessment Platform

**Purpose:** Complete database schema with ERD, table definitions, indexes, and migrations
**Generated by:** /design-database-schema
**File location:** `product-guidelines/07-database-schema.md`

> **Context**: This is a completed example showing journey-optimized database design for the compliance assessment platform.

---

## Overview

**Database**: PostgreSQL 15
**ORM/Migration Tool**: Prisma (TypeScript project)
**Total Tables**: 6 core tables
**Total Relationships**: 5 (4 one-to-many, 1 many-to-many)

**Journey Connection**:
This schema supports the following journey steps:
- **Step 1**: Upload document → `users`, `documents` tables
- **Step 2**: Select frameworks → `frameworks` table (system data)
- **Step 3**: AI assessment → `assessments` table with JSONB results
- **Step 4**: Review report → `assessments.results` field + shareable URLs
- **Billing**: Track usage → `usage_events` table

---

## Entity Relationship Diagram

```
┌──────────────┐
│    teams     │
│              │
│ id           │
│ name         │──┐
│ plan_tier    │  │
└──────────────┘  │
                  │ 1:N
                  │
┌─────────────────▼┐
│     users       │
│                 │
│ id              │
│ clerk_id        │
│ email           │──┐
│ team_id    (FK) │  │ 1:N
└─────────────────┘  │
                     │
      ┌──────────────▼───────┐
      │                      │
┌─────▼──────┐      ┌────────▼──────┐
│ documents  │      │ usage_events  │
│            │      │               │
│ id         │──┐   │ id            │
│ user_id    │  │   │ user_id  (FK) │
│ file_name  │  │   │ team_id  (FK) │
│ s3_key     │  │   │ event_type    │
│ status     │  │   └───────────────┘
└────────────┘  │ 1:N
                │
         ┌──────▼────────┐
         │ assessments   │
         │               │
         │ id            │
         │ user_id  (FK) │
         │ document_id   │──────┐
         │ status        │      │ M:N
         │ results (JSON)│      │
         └───────────────┘      │
                                │
                    ┌───────────▼──────────┐
                    │ assessment_frameworks│
                    │                      │
                    │ assessment_id   (FK) │
                    │ framework_id    (FK) │
                    └──────────────────┬───┘
                                       │
                                 ┌─────▼──────┐
                                 │ frameworks │
                                 │            │
                                 │ id         │
                                 │ code       │
                                 │ name       │
                                 │ definition │
                                 └────────────┘
```

**Entity Descriptions**:
- **teams**: Multi-tenant container (compliance officers belong to organizations)
- **users**: Individual compliance officers (authenticated via Clerk)
- **documents**: Uploaded compliance documents (PDFs stored in S3)
- **frameworks**: Compliance standards (SOC2, GDPR, HIPAA) - system-managed
- **assessments**: AI processing jobs that assess documents against frameworks
- **assessment_frameworks**: Join table for M:N relationship
- **usage_events**: Billing tracking (each assessment = billable event)

---

## Table Definitions

### teams

**Purpose**: Multi-tenant organization container - each compliance team has independent data

**Journey Context**: Users belong to teams, billing is per-team, data isolation by team

**Schema**:

| Column | Type | Constraints | Default | Purpose |
|--------|------|-------------|---------|---------|
| id | UUID | PRIMARY KEY | gen_random_uuid() | Unique team identifier |
| name | TEXT | NOT NULL | - | Team name (e.g., "Acme Corp Compliance") |
| plan_tier | TEXT | NOT NULL | 'free' | Subscription tier (free, business, enterprise) |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | When team was created |

**Indexes**:
- None needed (small table, <10K teams expected)

**Constraints**:
- **Primary Key**: id
- **Check**: `plan_tier IN ('free', 'business', 'enterprise')`

**Relationships**:
- **Has many**: users, usage_events

**Design Decisions**:
- **UUID for id**: Teams may be created across distributed systems (multi-region future)
- **plan_tier as TEXT**: Simple enough for CHECK constraint, not worth separate table
- **No soft deletes**: Team deletion rare, hard delete acceptable

---

### users

**Purpose**: Individual compliance officers who upload documents and run assessments

**Journey Context**: User in Step 1 (upload), Step 2 (select frameworks), Step 4 (review results)

**Schema**:

| Column | Type | Constraints | Default | Purpose |
|--------|------|-------------|---------|---------|
| id | UUID | PRIMARY KEY | gen_random_uuid() | Unique user identifier |
| clerk_id | TEXT | UNIQUE NOT NULL | - | External auth ID (Clerk) |
| email | TEXT | UNIQUE NOT NULL | - | User email (from Clerk) |
| team_id | UUID | REFERENCES teams(id) | NULL | Team membership (nullable for solo users) |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | When user signed up |

**Indexes**:
- `idx_users_team_id`: ON (team_id) - Filter users by team
- `idx_users_clerk_id`: ON (clerk_id) - Lookup by auth ID (implicit via UNIQUE)
- `idx_users_email`: ON (email) - Lookup by email (implicit via UNIQUE)

**Constraints**:
- **Primary Key**: id
- **Foreign Keys**:
  - team_id → teams(id) ON DELETE SET NULL (user stays active if team dissolved)
- **Unique**: clerk_id, email

**Relationships**:
- **Belongs to**: teams (optional - user can exist without team)
- **Has many**: documents, assessments, usage_events

**Design Decisions**:
- **clerk_id separate from email**: Clerk manages auth, email might change
- **team_id nullable**: Solo users (Free tier) don't need teams
- **ON DELETE SET NULL**: If team dissolved, user doesn't lose their account

---

### documents

**Purpose**: Uploaded compliance documents (PDFs, Word docs) stored in S3

**Journey Context**: Step 1 (user uploads 100-page compliance doc)

**Schema**:

| Column | Type | Constraints | Default | Purpose |
|--------|------|-------------|---------|---------|
| id | UUID | PRIMARY KEY | gen_random_uuid() | Unique document identifier |
| user_id | UUID | NOT NULL REFERENCES users(id) | - | Who uploaded this |
| file_name | TEXT | NOT NULL | - | Original filename |
| file_size_bytes | INTEGER | NOT NULL CHECK > 0 | - | File size for quota tracking |
| s3_key | TEXT | UNIQUE NOT NULL | - | S3 object key (bucket/user_id/doc_id.pdf) |
| status | TEXT | NOT NULL | 'uploading' | Upload status (uploading, ready, error) |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | When uploaded |

**Indexes**:
- `idx_documents_user_id`: ON (user_id) - "Show my documents"
- `idx_documents_created`: ON (created_at DESC) - "Most recent first"
- `idx_documents_s3_key`: ON (s3_key) - S3 lookups (implicit via UNIQUE)

**Constraints**:
- **Primary Key**: id
- **Foreign Keys**:
  - user_id → users(id) ON DELETE CASCADE (user deleted → their docs deleted for GDPR)
- **Unique**: s3_key (each S3 object = one document)
- **Check**: `file_size_bytes > 0`, `status IN ('uploading', 'ready', 'error')`

**Relationships**:
- **Belongs to**: users
- **Has many**: assessments

**Design Decisions**:
- **s3_key not file_name**: Multiple users might upload "compliance_doc.pdf"
- **file_size_bytes for quotas**: Track storage usage per user/team
- **ON DELETE CASCADE**: GDPR compliance - user deletion = all their data deleted
- **status field**: Track upload failures (S3 presigned URL might fail)

---

### frameworks

**Purpose**: Compliance standards/frameworks (SOC2, GDPR, HIPAA) - system-managed data

**Journey Context**: Step 2 (user selects which frameworks to assess against)

**Schema**:

| Column | Type | Constraints | Default | Purpose |
|--------|------|-------------|---------|---------|
| id | UUID | PRIMARY KEY | gen_random_uuid() | Unique framework identifier |
| code | TEXT | UNIQUE NOT NULL | - | Short code (SOC2, GDPR, HIPAA) |
| name | TEXT | NOT NULL | - | Full name (SOC 2 Type II) |
| description | TEXT | - | - | What this framework covers |
| definition | JSONB | NOT NULL | - | Framework requirements (structured) |
| active | BOOLEAN | NOT NULL | true | Can users select this? |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | When added to system |

**Indexes**:
- `idx_frameworks_code`: ON (code) - Lookup by code (implicit via UNIQUE)
- `idx_frameworks_active`: ON (active) WHERE active = true - "Show available frameworks"

**Constraints**:
- **Primary Key**: id
- **Unique**: code

**Relationships**:
- **Has many**: assessments (via assessment_frameworks join table)

**Design Decisions**:
- **JSONB for definition**: Framework requirements are complex, structured data (Claude needs this)
- **active flag not deleted_at**: Frameworks don't get deleted, just deactivated
- **System-managed**: Users don't create frameworks, admins seed this table
- **code vs name**: code for API (stable), name for UI (readable)

---

### assessments

**Purpose**: AI processing jobs - assess a document against selected frameworks

**Journey Context**: Step 3 (AI assesses document in 60 seconds)

**Schema**:

| Column | Type | Constraints | Default | Purpose |
|--------|------|-------------|---------|---------|
| id | UUID | PRIMARY KEY | gen_random_uuid() | Unique assessment identifier |
| user_id | UUID | NOT NULL REFERENCES users(id) | - | Who requested this |
| document_id | UUID | NOT NULL REFERENCES documents(id) | - | What document was assessed |
| status | TEXT | NOT NULL | 'pending' | Processing status |
| results | JSONB | - | - | AI findings (flexible structure from Claude) |
| error_message | TEXT | - | - | If status=failed, why |
| started_at | TIMESTAMPTZ | - | - | When processing began |
| completed_at | TIMESTAMPTZ | - | - | When processing finished |
| duration_ms | INTEGER | - | - | Processing time (for metrics) |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | When assessment created |

**Indexes**:
- `idx_assessments_user_id`: ON (user_id) - "Show my assessments"
- `idx_assessments_document_id`: ON (document_id) - "Show assessments for this document"
- `idx_assessments_status`: ON (status) - "Show pending assessments" (worker poll)
- `idx_assessments_created`: ON (created_at DESC) - "Most recent first"
- `idx_assessments_user_status`: ON (user_id, status) - "My pending assessments"

**Constraints**:
- **Primary Key**: id
- **Foreign Keys**:
  - user_id → users(id) ON DELETE CASCADE
  - document_id → documents(id) ON DELETE CASCADE
- **Check**: `status IN ('pending', 'processing', 'completed', 'failed')`

**Relationships**:
- **Belongs to**: users, documents
- **Has many**: frameworks (via assessment_frameworks join table)

**Design Decisions**:
- **JSONB for results**: Claude output structure may evolve (flexibility critical)
- **status enum**: Simple state machine (pending → processing → completed/failed)
- **duration_ms**: Track performance (North Star metric: <60 sec processing)
- **Timestamps separated**: started_at vs completed_at allows tracking queue time
- **ON DELETE CASCADE**: Document deleted → assessments deleted (orphan prevention)

---

### assessment_frameworks

**Purpose**: Join table for many-to-many relationship (assessments ↔ frameworks)

**Journey Context**: Step 2 (user selects multiple frameworks: SOC2 + GDPR + HIPAA)

**Schema**:

| Column | Type | Constraints | Default | Purpose |
|--------|------|-------------|---------|---------|
| id | UUID | PRIMARY KEY | gen_random_uuid() | Unique join record ID |
| assessment_id | UUID | NOT NULL REFERENCES assessments(id) | - | Which assessment |
| framework_id | UUID | NOT NULL REFERENCES frameworks(id) | - | Which framework |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | When linked |

**Indexes**:
- `idx_af_assessment`: ON (assessment_id) - "Get frameworks for assessment"
- `idx_af_framework`: ON (framework_id) - "Get assessments using framework"
- `idx_af_unique`: UNIQUE (assessment_id, framework_id) - No duplicate links

**Constraints**:
- **Primary Key**: id
- **Foreign Keys**:
  - assessment_id → assessments(id) ON DELETE CASCADE
  - framework_id → frameworks(id) ON DELETE RESTRICT (can't delete framework with assessments)
- **Unique**: (assessment_id, framework_id)

**Relationships**:
- **Belongs to**: assessments, frameworks

**Design Decisions**:
- **Separate id + unique constraint**: Allows easier ORM mapping vs composite PK
- **ON DELETE CASCADE**: Assessment deleted → join records deleted
- **ON DELETE RESTRICT**: Framework used in assessments → can't delete (data integrity)

---

### usage_events

**Purpose**: Billing tracking - record every billable event for metering

**Journey Context**: Billing system (Step 3 completion triggers usage event)

**Schema**:

| Column | Type | Constraints | Default | Purpose |
|--------|------|-------------|---------|---------|
| id | UUID | PRIMARY KEY | gen_random_uuid() | Unique event identifier |
| user_id | UUID | NOT NULL REFERENCES users(id) | - | Who triggered event |
| team_id | UUID | REFERENCES teams(id) | - | Which team (for team billing) |
| event_type | TEXT | NOT NULL | - | Type of event (assessment_completed) |
| assessment_id | UUID | REFERENCES assessments(id) | - | Related assessment (if applicable) |
| billable | BOOLEAN | NOT NULL | true | Count towards billing? |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | When event occurred |

**Indexes**:
- `idx_usage_team_month`: ON (team_id, DATE_TRUNC('month', created_at)) - Billing queries
- `idx_usage_user`: ON (user_id) - User usage queries
- `idx_usage_created`: ON (created_at DESC) - Recent events

**Constraints**:
- **Primary Key**: id
- **Foreign Keys**:
  - user_id → users(id) ON DELETE RESTRICT (can't delete user with billing history)
  - team_id → teams(id) ON DELETE RESTRICT
  - assessment_id → assessments(id) ON DELETE SET NULL (assessment deleted, keep billing record)

**Relationships**:
- **Belongs to**: users, teams, assessments (optional)

**Design Decisions**:
- **ON DELETE RESTRICT for user/team**: Billing records immutable (legal requirement)
- **billable flag**: Free tier gets non-billable events (for analytics)
- **event_type TEXT**: Extensible for future event types (document_upload, etc.)
- **Composite index on team + month**: Optimizes "calculate monthly bill" query

---

## Relationships Summary

### One-to-Many Relationships

**teams → users**:
- Description: A team has multiple compliance officers
- Foreign Key: users.team_id
- On Delete: SET NULL (user keeps account if team dissolved)
- Journey Context: Multi-tenant isolation (team A can't see team B's docs)

**users → documents**:
- Description: A user uploads multiple documents
- Foreign Key: documents.user_id
- On Delete: CASCADE (GDPR compliance - delete user = delete their data)
- Journey Context: Journey Step 1 (upload)

**users → assessments**:
- Description: A user runs multiple assessments
- Foreign Key: assessments.user_id
- On Delete: CASCADE (user deletion cascades)
- Journey Context: Journey Step 3 (assess)

**documents → assessments**:
- Description: A document can be assessed multiple times (different frameworks, re-runs)
- Foreign Key: assessments.document_id
- On Delete: CASCADE (document deleted = assessments deleted)
- Journey Context: User might assess same doc against SOC2, then GDPR separately

### Many-to-Many Relationships

**assessments ↔ frameworks**:
- Description: An assessment checks multiple frameworks, frameworks used by many assessments
- Join Table: assessment_frameworks
- Foreign Keys:
  - assessment_frameworks.assessment_id → assessments(id) ON DELETE CASCADE
  - assessment_frameworks.framework_id → frameworks(id) ON DELETE RESTRICT
- Journey Context: Step 2 - user selects multiple frameworks to assess against

---

## Indexes Strategy

### Query Patterns from Backlog

**Pattern 1: User dashboard - "Show my recent assessments"**

```sql
SELECT a.*, d.file_name
FROM assessments a
JOIN documents d ON a.document_id = d.id
WHERE a.user_id = $1
ORDER BY a.created_at DESC
LIMIT 20;
```

- **Indexes Used**:
  - `idx_assessments_user_id` (filter by user)
  - `idx_assessments_created` (sort by created_at DESC)
- **Reasoning**: Most common query (every dashboard load)
- **Estimated Frequency**: 100+ times/day per active user

**Pattern 2: Worker queue - "Get next pending assessment"**

```sql
SELECT a.*, d.s3_key
FROM assessments a
JOIN documents d ON a.document_id = d.id
WHERE a.status = 'pending'
ORDER BY a.created_at ASC
LIMIT 1
FOR UPDATE SKIP LOCKED;
```

- **Indexes Used**:
  - `idx_assessments_status` (filter pending)
  - `idx_assessments_created` (oldest first)
- **Reasoning**: Background worker polls for jobs
- **Estimated Frequency**: Every 5 seconds (high frequency)

**Pattern 3: Billing - "Calculate team usage for current month"**

```sql
SELECT COUNT(*) as assessment_count
FROM usage_events
WHERE team_id = $1
  AND billable = true
  AND created_at >= DATE_TRUNC('month', NOW())
  AND created_at < DATE_TRUNC('month', NOW()) + INTERVAL '1 month';
```

- **Indexes Used**:
  - `idx_usage_team_month` (composite: team_id, DATE_TRUNC('month', created_at))
- **Reasoning**: Billing calculation (monthly)
- **Estimated Frequency**: Daily (usage meter) + monthly (invoice generation)

**Pattern 4: Framework selection - "Show active frameworks"**

```sql
SELECT id, code, name, description
FROM frameworks
WHERE active = true
ORDER BY name;
```

- **Indexes Used**:
  - `idx_frameworks_active` (partial index WHERE active = true)
- **Reasoning**: Framework picker UI (Step 2)
- **Estimated Frequency**: Every assessment creation

**Pattern 5: Assessment details - "Get assessment with frameworks"**

```sql
SELECT
  a.*,
  d.file_name,
  ARRAY_AGG(f.code) as framework_codes
FROM assessments a
JOIN documents d ON a.document_id = d.id
JOIN assessment_frameworks af ON a.id = af.assessment_id
JOIN frameworks f ON af.framework_id = f.id
WHERE a.id = $1
GROUP BY a.id, d.file_name;
```

- **Indexes Used**:
  - Primary key lookups (very fast)
  - `idx_af_assessment` (get frameworks for assessment)
- **Reasoning**: Assessment detail view (Step 4)
- **Estimated Frequency**: Every time user views results

### Index Coverage

- **Foreign Key Indexes**: 8 (all foreign keys indexed for joins)
- **Filter Indexes**: 4 (WHERE clause optimization)
- **Sort Indexes**: 3 (ORDER BY optimization)
- **Composite Indexes**: 2 (multi-column queries)
- **Partial Indexes**: 1 (filtered common query)

---

## Data Constraints Philosophy

### NOT NULL Constraints

**Philosophy**: If the journey requires it, the database enforces it

- `users.email`: NOT NULL because required for authentication (journey step 0)
- `documents.s3_key`: NOT NULL because document without storage makes no sense
- `assessments.status`: NOT NULL because state machine must always have state

### UNIQUE Constraints

**Philosophy**: Business rules preventing duplicates

- `users.email`: Each email = one account (business rule)
- `frameworks.code`: Each framework has unique code (SOC2, GDPR, etc.)
- `(assessment_id, framework_id)`: Same framework not selected twice for one assessment

### CHECK Constraints

**Philosophy**: Enforce valid states at database level (fail fast)

- `teams.plan_tier IN ('free', 'business', 'enterprise')`: Only valid subscription tiers
- `documents.status IN ('uploading', 'ready', 'error')`: Only valid upload states
- `assessments.status IN ('pending', 'processing', 'completed', 'failed')`: Valid workflow states
- `documents.file_size_bytes > 0`: File must have content

### Foreign Key Referential Actions

**ON DELETE CASCADE**:
- `users → documents, assessments`: User deleted → their data deleted (GDPR compliance)
- `documents → assessments`: Document deleted → orphan assessments deleted
- `assessments → assessment_frameworks`: Assessment deleted → join records deleted

**ON DELETE RESTRICT**:
- `frameworks → assessment_frameworks`: Can't delete framework referenced by assessments
- `users/teams → usage_events`: Can't delete entity with billing history (legal requirement)

**ON DELETE SET NULL**:
- `teams → users`: Team dissolved → user.team_id becomes NULL (user keeps account)
- `assessments → usage_events`: Assessment deleted → keep billing record (set FK to NULL)

---

## Migration Files

### Prisma Schema (TypeScript)

**File**: `product-guidelines/07-database-schema/prisma/schema.prisma`

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Team {
  id        String   @id @default(cuid())
  name      String
  planTier  String   @default("free") @map("plan_tier")
  createdAt DateTime @default(now()) @map("created_at")

  users        User[]
  usageEvents  UsageEvent[]

  @@map("teams")
}

model User {
  id        String   @id @default(cuid())
  clerkId   String   @unique @map("clerk_id")
  email     String   @unique
  teamId    String?  @map("team_id")
  createdAt DateTime @default(now()) @map("created_at")

  team        Team?        @relation(fields: [teamId], references: [id], onDelete: SetNull)
  documents   Document[]
  assessments Assessment[]
  usageEvents UsageEvent[]

  @@index([teamId])
  @@map("users")
}

model Document {
  id            String   @id @default(cuid())
  userId        String   @map("user_id")
  fileName      String   @map("file_name")
  fileSizeBytes Int      @map("file_size_bytes")
  s3Key         String   @unique @map("s3_key")
  status        String   @default("uploading")
  createdAt     DateTime @default(now()) @map("created_at")

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  assessments Assessment[]

  @@index([userId])
  @@index([createdAt(sort: Desc)])
  @@map("documents")
}

model Framework {
  id          String   @id @default(cuid())
  code        String   @unique
  name        String
  description String?
  definition  Json
  active      Boolean  @default(true)
  createdAt   DateTime @default(now()) @map("created_at")

  assessmentFrameworks AssessmentFramework[]

  @@index([active])
  @@map("frameworks")
}

model Assessment {
  id          String    @id @default(cuid())
  userId      String    @map("user_id")
  documentId  String    @map("document_id")
  status      String    @default("pending")
  results     Json?
  errorMessage String?  @map("error_message")
  startedAt   DateTime? @map("started_at")
  completedAt DateTime? @map("completed_at")
  durationMs  Int?      @map("duration_ms")
  createdAt   DateTime  @default(now()) @map("created_at")

  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  document             Document              @relation(fields: [documentId], references: [id], onDelete: Cascade)
  assessmentFrameworks AssessmentFramework[]
  usageEvents          UsageEvent[]

  @@index([userId])
  @@index([documentId])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@index([userId, status])
  @@map("assessments")
}

model AssessmentFramework {
  id           String   @id @default(cuid())
  assessmentId String   @map("assessment_id")
  frameworkId  String   @map("framework_id")
  createdAt    DateTime @default(now()) @map("created_at")

  assessment Assessment @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  framework  Framework  @relation(fields: [frameworkId], references: [id], onDelete: Restrict)

  @@unique([assessmentId, frameworkId])
  @@index([assessmentId])
  @@index([frameworkId])
  @@map("assessment_frameworks")
}

model UsageEvent {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  teamId       String?  @map("team_id")
  eventType    String   @map("event_type")
  assessmentId String?  @map("assessment_id")
  billable     Boolean  @default(true)
  createdAt    DateTime @default(now()) @map("created_at")

  user       User        @relation(fields: [userId], references: [id], onDelete: Restrict)
  team       Team?       @relation(fields: [teamId], references: [id], onDelete: Restrict)
  assessment Assessment? @relation(fields: [assessmentId], references: [id], onDelete: SetNull)

  @@index([teamId, createdAt])
  @@index([userId])
  @@map("usage_events")
}
```

**To apply**:

```bash
# 1. Copy schema to your project
cp product-guidelines/07-database-schema/prisma/schema.prisma ./prisma/schema.prisma

# 2. Create initial migration
npx prisma migrate dev --name initial_schema

# 3. Generate Prisma client
npx prisma generate

# 4. (Optional) Open Prisma Studio to view data
npx prisma studio
```

---

## Scaling Considerations

### Current Scale Estimate (from metrics)

- **Users**: 1,000 users (Year 1 target from North Star metric)
- **Assessments per month**: 10,000 (from "Weekly Active Assessments" × 4 weeks)
- **Data growth rate**: ~2GB/month (documents + assessment results)

### Table Size Projections (Year 1)

- `users`: ~1,000 rows (~50KB - very small)
- `teams`: ~200 rows (~10KB - tiny)
- `documents`: ~20,000 rows (~2MB metadata, 50GB in S3)
- `assessments`: ~120,000 rows (~500MB with JSONB results)
- `frameworks`: ~20 rows (~50KB - static)
- `assessment_frameworks`: ~360,000 rows (~15MB - join table)
- `usage_events`: ~120,000 rows (~10MB - billing records)

**Total database size Year 1**: ~525MB (easily fits in memory)

### When to Optimize

**Read Replicas** (if read load > write load):
- **When**: >1000 concurrent users OR read queries > 1000/sec
- **For tables**: `frameworks` (rarely change, heavily read)
- **Not needed**: Year 1 (single PostgreSQL instance handles 10K assessments/month)

**Partitioning** (if table grows large):
- **When**: `assessments` table >10M rows (~Year 5+)
- **Strategy**: Partition by `created_at` (monthly partitions)
- **Reasoning**: Recent assessments queried frequently, old ones archived
- **Not needed**: Year 1-3

**Sharding** (if single database too small):
- **When**: >50M rows total OR >500GB database
- **Strategy**: Shard by `team_id` (each team's data on separate shard)
- **Reasoning**: Teams don't query each other's data (perfect shard key)
- **Not needed**: Year 1-5 (PostgreSQL scales to 500GB+ easily)

### Archival Strategy

**Assessments archival** (after 90 days for Free tier, unlimited for paid):
- Move `assessments.results` to S3 cold storage
- Keep metadata in database (id, status, created_at) for references
- Lazy load results from S3 if user requests old assessment

**Usage events archival** (after billing period closed):
- After monthly invoice generated, move to data warehouse (BigQuery, Snowflake)
- Keep current month + 3 months in PostgreSQL for dispute resolution

---

## Testing Strategy

### Seed Data (Development)

```sql
-- Insert test team
INSERT INTO teams (id, name, plan_tier) VALUES
  ('test-team-id', 'Acme Corp', 'business');

-- Insert test users
INSERT INTO users (id, clerk_id, email, team_id) VALUES
  ('test-user-1', 'clerk_user_1', 'alice@acme.com', 'test-team-id'),
  ('test-user-2', 'clerk_user_2', 'bob@acme.com', 'test-team-id');

-- Insert frameworks
INSERT INTO frameworks (id, code, name, definition, active) VALUES
  ('fw-soc2', 'SOC2', 'SOC 2 Type II', '{"requirements": [...]}', true),
  ('fw-gdpr', 'GDPR', 'General Data Protection Regulation', '{"articles": [...]}', true);

-- Insert test documents
INSERT INTO documents (id, user_id, file_name, file_size_bytes, s3_key, status) VALUES
  ('doc-1', 'test-user-1', 'privacy_policy.pdf', 1024000, 'docs/test-user-1/doc-1.pdf', 'ready');

-- Insert test assessment
INSERT INTO assessments (id, user_id, document_id, status) VALUES
  ('assess-1', 'test-user-1', 'doc-1', 'completed');

-- Link assessment to frameworks
INSERT INTO assessment_frameworks (assessment_id, framework_id) VALUES
  ('assess-1', 'fw-soc2'),
  ('assess-1', 'fw-gdpr');
```

### Migration Testing Checklist

```
✓ Apply migration to empty database → Success
✓ Seed test data → Success
✓ Run user dashboard query → Returns expected results (<50ms)
✓ Run billing query → Correct assessment count
✓ Test ON DELETE CASCADE → Deleting user deletes their documents
✓ Test ON DELETE RESTRICT → Can't delete framework with assessments
✓ Test UNIQUE constraints → Can't insert duplicate email
✓ Test CHECK constraints → Can't insert invalid status
✓ Rollback migration (if supported) → Success
```

---

## Design Decisions Summary

### What We Chose and Why

**PostgreSQL with JSONB**:
- **Why**: Relational for structured data (users, documents), JSONB for flexible data (assessment results)
- **Journey reasoning**: Stable entities (users, teams) benefit from relational integrity; AI results evolve (JSONB flexibility)
- **Trade-off accepted**: JSONB queries slower than columns, but Claude output format will evolve

**UUID primary keys**:
- **Why**: Distributed-safe (future multi-region), non-guessable (security)
- **Journey reasoning**: Assessment URLs shouldn't expose sequential IDs
- **Trade-off accepted**: 16 bytes vs 8 bytes (BIGINT), larger indexes, acceptable for <10M rows

**ON DELETE CASCADE for user data**:
- **Why**: GDPR compliance ("right to be forgotten")
- **Journey reasoning**: User deletion must delete all their documents and assessments
- **Trade-off accepted**: Accidental deletions are permanent (mitigated by soft delete in application layer)

**Polling (status field) not WebSockets**:
- **Why**: Assessments take 30-60 seconds (polling acceptable)
- **Journey reasoning**: Real-time updates <1 second not required
- **Trade-off accepted**: Slightly higher server load (acceptable, saves WebSocket complexity)

---

**Generated**: 2025-11-11
**Database**: PostgreSQL 15
**ORM**: Prisma
**Total Tables**: 6
**Ready for**: Feature implementation
