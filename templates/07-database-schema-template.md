# Database Schema Design

**Purpose:** Complete database schema with ERD, table definitions, indexes, and migrations
**Generated by:** /design-database-schema
**File location:** `product-guidelines/07-database-schema.md`

---

## Overview

**Database**: [PostgreSQL/MongoDB/MySQL/etc. from tech stack]
**ORM/Migration Tool**: [Prisma/Alembic/TypeORM/etc. from tech stack]
**Total Tables**: [Number]
**Total Relationships**: [Number]

**Journey Connection**:
This schema supports the following journey steps:
- Step 1: [Journey step] → [Tables used]
- Step 2: [Journey step] → [Tables used]
- Step 3: [Journey step] → [Tables used]
- Step 4: [Journey step] → [Tables used]

---

## Entity Relationship Diagram

```
[Visual ERD using Mermaid or ASCII art]

Example:
┌─────────────┐       ┌──────────────┐
│    Teams    │───────│    Users     │
└─────────────┘  1:N  └──────┬───────┘
                              │ 1:N
                      ┌───────▼────────┐
                      │   Documents    │
                      └───────┬────────┘
                              │ 1:N
                      ┌───────▼────────┐       ┌──────────────┐
                      │  Assessments   │───────│  Frameworks  │
                      └────────────────┘  M:N  └──────────────┘
```

**Entity Descriptions**:
- **[Entity 1]**: [Purpose - what it represents in user journey]
- **[Entity 2]**: [Purpose]
- **[Entity 3]**: [Purpose]

---

## Table Definitions

### [Table Name 1] (e.g., users)

**Purpose**: [Why this table exists - connection to user journey]

**Journey Context**: Used in [Journey Step X] when [user action]

**Schema**:

| Column | Type | Constraints | Default | Purpose |
|--------|------|-------------|---------|---------|
| id | UUID | PRIMARY KEY | gen_random_uuid() | Unique identifier |
| [column] | [type] | [constraints] | [default] | [purpose] |

**Indexes**:
- `idx_[name]`: [Columns] - Used for [query pattern from backlog]
- `idx_[name]`: [Columns] - Used for [query pattern]

**Constraints**:
- **Primary Key**: id
- **Foreign Keys**:
  - [column] → [referenced_table]([referenced_column]) [ON DELETE CASCADE/RESTRICT]
- **Unique**: [columns that must be unique]
- **Check**: [any CHECK constraints with reasoning]

**Relationships**:
- **Belongs to**: [Parent table name] via [foreign key column]
- **Has many**: [Child table names]

**Design Decisions**:
- **Why UUID vs BIGINT**: [Reasoning - distribution, security, etc.]
- **Why [data type choice]**: [Reasoning based on journey requirements]
- **Why [nullable/not null]**: [Reasoning]

---

### [Table Name 2]

[Repeat structure above for each table]

---

## Relationships

### One-to-Many Relationships

**[Parent] → [Child]**:
- Description: [What this relationship represents]
- Foreign Key: [child_table].[foreign_key_column]
- On Delete: [CASCADE/RESTRICT/SET NULL]
- Journey Context: [How this relationship serves user journey]

### Many-to-Many Relationships

**[Entity A] ↔ [Entity B]**:
- Description: [What this relationship represents]
- Join Table: [table_name]
- Foreign Keys:
  - [entity_a_id] → [table_a](id)
  - [entity_b_id] → [table_b](id)
- Journey Context: [How this relationship serves user journey]

---

## Indexes Strategy

### Query Patterns from Backlog

**Pattern 1: [Description of common query]**
```sql
SELECT * FROM [table] WHERE [conditions] ORDER BY [column];
```
- **Index**: `idx_[name]` on ([columns])
- **Reasoning**: [Why this index optimizes this query]
- **Estimated Frequency**: [How often - based on journey step usage]

**Pattern 2: [Description]**
[Continue for 3-5 main query patterns]

### Index Coverage

- **Foreign Key Indexes**: [Count] (all foreign keys indexed for joins)
- **Filter Indexes**: [Count] (for WHERE clauses)
- **Sort Indexes**: [Count] (for ORDER BY clauses)
- **Composite Indexes**: [Count] (for multi-column queries)
- **Partial Indexes**: [Count] (for filtered queries)

**Reasoning for each composite index**:
- `idx_[name]` ([col1], [col2]): [Query pattern it serves + why this column order]

---

## Data Constraints

### NOT NULL Constraints

**Philosophy**: Required from user perspective = NOT NULL in database

- `[table].[column]`: NOT NULL because [journey reasoning]
- Example: `users.email`: Required for authentication (journey step 0)

### UNIQUE Constraints

**Philosophy**: Business rule preventing duplicates

- `[table].[column]`: UNIQUE because [business rule from journey]
- Example: `users.email`: Each email belongs to one user account

### CHECK Constraints

**Philosophy**: Enforce valid states at database level

- `[table].[column]`: CHECK because [valid values from journey/architecture]
- Example: `assessments.status`: Must be one of [pending, processing, completed, failed]

### Foreign Key Constraints

**Philosophy**: Referential integrity protects data consistency

**ON DELETE CASCADE**:
- `[child].[fk]` → `[parent].[id]`: When [parent] deleted, [child] should also be deleted
- Example: When user deleted, their documents should be deleted (GDPR compliance)

**ON DELETE RESTRICT**:
- `[child].[fk]` → `[parent].[id]`: When [parent] has [children], deletion blocked
- Example: Can't delete framework if assessments reference it (data integrity)

**ON DELETE SET NULL**:
- `[child].[fk]` → `[parent].[id]`: When [parent] deleted, [child] becomes orphaned
- Example: When team disbanded, user.team_id becomes NULL (user keeps account)

---

## Migration Files

### Generated Migration: [Migration Name]

**Migration Tool**: [Prisma/Alembic/etc.]
**Target Database**: [PostgreSQL/MySQL/etc.]
**File Location**: `product-guidelines/07-database-schema/migrations/[filename]`

**What this migration does**:
1. Creates [N] tables
2. Defines [N] relationships
3. Creates [N] indexes
4. Adds [N] constraints

**To apply migration**:
```bash
[Commands to run migration - Prisma, Alembic, or raw SQL]
```

**To rollback** (if needed):
```bash
[Rollback commands]
```

---

## Query Examples

### Critical Path Queries (Journey Steps 1-3)

**Query 1: [Description from journey]**

```sql
[SQL query]
```

**EXPLAIN ANALYZE Notes**:
- Index used: `[index_name]`
- Estimated rows: [number]
- Execution time: [milliseconds]

**Query 2: [Description]**
[Continue for 3-5 most critical queries]

### Billing/Analytics Queries

**Query: Calculate monthly usage for billing**

```sql
SELECT
  team_id,
  COUNT(*) as assessments_completed,
  DATE_TRUNC('month', created_at) as month
FROM assessments
WHERE status = 'completed'
  AND created_at >= NOW() - INTERVAL '3 months'
GROUP BY team_id, month
ORDER BY month DESC;
```

**Index**: `idx_assessments_team_month` on (team_id, DATE_TRUNC('month', created_at))

---

## Data Types Rationale

**UUID vs BIGINT for IDs**:
- **Choice**: [UUID/BIGINT]
- **Reasoning**: [Based on architecture - distributed system? Security? Scale?]
- **Trade-offs**: [UUIDs = larger indexes but distributed-safe, BIGINT = smaller but sequential]

**VARCHAR vs TEXT**:
- **Choice**: [Use TEXT everywhere / Use VARCHAR with limits]
- **Reasoning**: [Based on database choice and query patterns]
- **Trade-offs**: [VARCHAR enforces length, TEXT is unlimited]

**JSONB vs Separate Columns**:
- **When JSONB**: [assessment results - structure evolves]
- **When Columns**: [user profile - stable structure]
- **Reasoning**: [Flexibility vs query performance]

**TIMESTAMPTZ vs TIMESTAMP**:
- **Choice**: TIMESTAMPTZ (timezone-aware)
- **Reasoning**: [Global users - different timezones]
- **Trade-offs**: [Slightly larger storage, but prevents timezone bugs]

**Arrays vs Join Tables**:
- **When Arrays**: [Small, fixed lists - tags, labels]
- **When Join Tables**: [Entities with attributes - assessments & frameworks]
- **Reasoning**: [Query flexibility vs simplicity]

---

## Scaling Considerations

### Current Scale Estimate (from journey/metrics)

- **Users**: [Estimated from metrics]
- **Assessments per month**: [From North Star metric]
- **Data growth rate**: [GB per month]

### Table Size Projections (Year 1)

- `users`: ~[N] rows (~[MB])
- `assessments`: ~[N] rows (~[GB])
- `usage_events`: ~[N] rows (~[GB])

### When to Optimize

**Read Replicas** (if read load > write load):
- When: [Metric threshold - e.g., >1000 reads/sec]
- For tables: [users, frameworks - rarely change]

**Partitioning** (if table grows large):
- When: [Metric threshold - e.g., >10M rows]
- Strategy: Partition `assessments` by created_at (monthly partitions)
- Reasoning: Recent assessments queried frequently, old ones archived

**Sharding** (if single database too small):
- When: [Metric threshold - e.g., >50M rows, >500GB]
- Strategy: Shard by team_id (each team's data on separate database)
- Reasoning: Teams don't query each other's data (perfect shard key)

### Archival Strategy

**Which tables need archiving**:
- `assessments`: Older than [N days/months] can be moved to cold storage
- `usage_events`: After billing period closed, move to data warehouse

**Archival method**:
- Partition by month, drop old partitions to S3 / Glacier
- Keep metadata in main database for lookups

---

## Testing Strategy

### Seed Data

**Minimal seed data** (for development):
```sql
[SQL to insert test users, documents, frameworks]
```

**Realistic seed data** (for testing):
- [N] users across [N] teams
- [N] documents
- [N] assessments in various states
- Reasoning: Tests query performance at realistic scale

### Schema Validation Tests

```
✓ All foreign keys reference existing tables
✓ All indexes are used by queries (no unused indexes)
✓ All NOT NULL columns have defaults or are user-provided
✓ All CHECK constraints allow valid journey states
✓ All timestamps are timezone-aware
```

### Migration Testing

```
1. Apply migration to empty database → Success
2. Seed data → Success
3. Run query tests → Success
4. Rollback migration → Success (if supported)
```

---

## Design Decisions Summary

### What We Chose

**[Decision 1]**: [What was chosen]
- **Why**: [Journey-based reasoning]
- **Trade-off accepted**: [What we gave up]

**[Decision 2]**: [What was chosen]
- **Why**: [Tech stack alignment]
- **Trade-off accepted**: [Simplicity vs feature]

### What We DIDN'T Choose (see main document)

Summary of key alternatives:
- [Alternative 1]: [When to reconsider]
- [Alternative 2]: [When to reconsider]
- [Alternative 3]: [When to reconsider]

---

## Maintenance Guidelines

### Adding New Tables

1. **Identify journey need**: What user problem requires this data?
2. **Check existing tables**: Can existing table be extended?
3. **Define relationships**: How does this relate to existing entities?
4. **Create migration**: Use ORM tooling
5. **Add indexes**: Based on expected query patterns
6. **Update this document**: Keep ERD and schema docs in sync

### Modifying Existing Tables

**Safe changes** (no downtime):
- Adding nullable columns
- Adding indexes (with CONCURRENTLY in PostgreSQL)
- Adding CHECK constraints for new rows

**Risky changes** (may require downtime):
- Changing column types
- Adding NOT NULL columns (need default or backfill)
- Removing columns (may break application)

**Migration strategy**:
1. Write migration with up/down
2. Test on staging database
3. Run during low-traffic window
4. Monitor for errors

---

## Validation

This schema design is complete when:

- [ ] All journey steps have database support
- [ ] All backlog features can be implemented with this schema
- [ ] All relationships have appropriate foreign keys
- [ ] All query patterns from backlog have indexes
- [ ] All constraints prevent invalid states
- [ ] Migration files run successfully on clean database
- [ ] "What We DIDN'T Choose" section explains 3+ alternatives

---

## References

- **User Journey**: `product-guidelines/00-user-journey.md`
- **Tech Stack**: `product-guidelines/02-tech-stack.md`
- **Architecture**: `product-guidelines/05-architecture.md`
- **Backlog**: `product-guidelines/07-backlog/BACKLOG.md`
- **Migration Files**: `product-guidelines/07-database-schema/migrations/`

---

**Generated**: [Date]
**Database**: [Type]
**ORM**: [Tool]
**Total Tables**: [Count]
**Ready for**: Development implementation
